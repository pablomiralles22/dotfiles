(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = void 0;
const coc_nvim_1 = __webpack_require__(1);
const commands_1 = __webpack_require__(2);
const typeScriptExtensionId = 'coc-tsserver';
const denoExtensionId = 'coc-deno';
const pluginId = 'typescript-deno-plugin';
const configurationSection = 'deno';
class DenoCacheActionProvider {
    async provideCodeActions(document, _range, context) {
        const actions = [];
        for (const diagnostic of context.diagnostics) {
            if (diagnostic.message.includes('https://deno.land')) {
                actions.push({
                    title: `Run 'deno cache' to fix importing error`,
                    command: {
                        title: `deno cache`,
                        command: `deno.cache`,
                        arguments: [document.uri],
                    },
                });
            }
        }
        return actions;
    }
}
function withConfigValue(config, outConfig, key) {
    const configSetting = config.inspect(key);
    if (!configSetting) {
        return;
    }
    if (typeof configSetting.globalValue === 'undefined' && typeof configSetting.workspaceValue === 'undefined') {
        return;
    }
    const value = config.get(key, undefined);
    if (typeof value !== 'undefined') {
        outConfig[key] = value;
    }
}
function getConfiguration() {
    const config = coc_nvim_1.workspace.getConfiguration(configurationSection);
    const outConfig = {};
    withConfigValue(config, outConfig, 'enable');
    withConfigValue(config, outConfig, 'alwaysShowStatus');
    withConfigValue(config, outConfig, 'autoFmtOnSave');
    withConfigValue(config, outConfig, 'importmap');
    withConfigValue(config, outConfig, 'tsconfig');
    withConfigValue(config, outConfig, 'unstable');
    return outConfig;
}
function synchronizeConfiguration(api) {
    if (!api)
        return;
    api.configurePlugin(pluginId, getConfiguration());
}
async function activate(context) {
    const enabled = coc_nvim_1.workspace.getConfiguration(configurationSection).get('enable', true);
    if (!enabled) {
        return;
    }
    const extension = coc_nvim_1.extensions.getExtension(typeScriptExtensionId).extension;
    if (!extension) {
        return;
    }
    await extension.activate();
    if (!extension.exports) {
        return;
    }
    const api = extension.exports;
    if (!api) {
        return;
    }
    coc_nvim_1.workspace.onDidChangeConfiguration((e) => {
        if (e.affectsConfiguration(configurationSection)) {
            synchronizeConfiguration(api);
        }
    }, null, context.subscriptions);
    synchronizeConfiguration(api);
    const outputChannel = coc_nvim_1.workspace.createOutputChannel(configurationSection);
    const disposables = [outputChannel, coc_nvim_1.commands.registerCommand('deno.cache', commands_1.denoCache), coc_nvim_1.commands.registerCommand('deno.types', commands_1.denoTypes)];
    context.subscriptions.push(...disposables);
    const provider = new DenoCacheActionProvider();
    context.subscriptions.push(coc_nvim_1.languages.registerCodeActionProvider(['typescript'], provider, 'deno'));
    const info = await commands_1.denoInfo();
    outputChannel.appendLine(info);
}
exports.activate = activate;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("coc.nvim");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.denoTypes = exports.denoCache = exports.denoInfo = void 0;
const child_process_1 = __webpack_require__(3);
const coc_nvim_1 = __webpack_require__(1);
const fs = __importStar(__webpack_require__(4));
const path = __importStar(__webpack_require__(5));
const util_1 = __webpack_require__(6);
const which_1 = __importDefault(__webpack_require__(7));
const execPromise = util_1.promisify(child_process_1.exec);
function denoBin() {
    const bin = process.platform === 'win32' ? 'deno.exe' : 'deno';
    if (!which_1.default.sync(bin, { nothrow: true })) {
        return;
    }
    return bin;
}
async function denoInfo() {
    const bin = denoBin();
    if (!bin)
        return 'No deno found';
    try {
        const version = await execPromise(`${bin} --version`);
        if (version.stderr) {
            return `deno version failed: \n${version.stderr}`;
        }
        const info = await execPromise(`${bin} info`);
        if (info.stderr) {
            return `${version.stdout}\ndeno info failed:\n${info.stderr}`;
        }
        // https://stackoverflow.com/a/29497680/380774
        const infoStr = info.stdout.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
        return `${version.stdout}\n${infoStr}`;
    }
    catch (_a) {
        return 'deno info failed';
    }
}
exports.denoInfo = denoInfo;
async function denoCache(uri) {
    const bin = denoBin();
    if (!bin) {
        return;
    }
    if (!uri) {
        const doc = await coc_nvim_1.workspace.document;
        if (!doc) {
            return;
        }
        uri = doc.uri;
    }
    try {
        uri = coc_nvim_1.Uri.parse(uri).fsPath;
        coc_nvim_1.workspace.showMessage(`deno cache ${uri}...`);
        await execPromise(`${bin} cache ${uri}`);
        await coc_nvim_1.commands.executeCommand('editor.action.restart');
    }
    catch (_a) {
        coc_nvim_1.workspace.showMessage(`deno cache failed: ${uri}`, 'error');
    }
}
exports.denoCache = denoCache;
function getDenoDir() {
    // ref https://deno.land/manual.html
    // On Linux/Redox: $XDG_CACHE_HOME/deno or $HOME/.cache/deno
    // On Windows: %LOCALAPPDATA%/deno (%LOCALAPPDATA% = FOLDERID_LocalAppData)
    // On macOS: $HOME/Library/Caches/deno
    // If something fails, it falls back to $HOME/.deno
    let denoDir = process.env.DENO_DIR;
    if (!denoDir) {
        switch (process.platform) {
            case 'win32':
                denoDir = `${process.env.LOCALAPPDATA}\\deno`;
                break;
            case 'darwin':
                denoDir = `${process.env.HOME}/Library/Caches/deno`;
                break;
            case 'linux':
                denoDir = `${process.env.HOME}/.cache/deno`;
                break;
            default:
                denoDir = `${process.env.HOME}/.deno`;
        }
    }
    return denoDir;
}
async function denoTypes() {
    const bin = denoBin();
    if (!bin) {
        return;
    }
    const denoDir = getDenoDir();
    if (!fs.existsSync(denoDir)) {
        fs.mkdirSync(denoDir, { recursive: true });
    }
    try {
        const args = ['types'];
        const unstable = coc_nvim_1.workspace.getConfiguration('deno').get('unstable');
        if (unstable)
            args.push('--unstable');
        const { stdout, stderr } = await execPromise(`${bin} ${args.join(' ')}`);
        if (stderr) {
            return;
        }
        fs.writeFileSync(path.resolve(denoDir, 'lib.deno.d.ts'), stdout);
    }
    catch (_a) { }
}
exports.denoTypes = denoTypes;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

const path = __webpack_require__(5)
const COLON = isWindows ? ';' : ':'
const isexe = __webpack_require__(8)

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    )
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : ''
  const pathExt = isWindows ? pathExtExe.split(colon) : ['']

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
}

const which = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }
  if (!opt)
    opt = {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    resolve(subStep(p, i, 0))
  })

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii]
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext)
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    })
  })

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
}

const whichSync = (cmd, opt) => {
  opt = opt || {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j]
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}

module.exports = which
which.sync = whichSync


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(4)
var core
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = __webpack_require__(9)
} else {
  core = __webpack_require__(10)
}

module.exports = isexe
isexe.sync = sync

function isexe (path, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er)
        } else {
          resolve(is)
        }
      })
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null
        is = false
      }
    }
    cb(er, is)
  })
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(4)

function checkPathExt (path, options) {
  var pathext = options.pathExt !== undefined ?
    options.pathExt : process.env.PATHEXT

  if (!pathext) {
    return true
  }

  pathext = pathext.split(';')
  if (pathext.indexOf('') !== -1) {
    return true
  }
  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase()
    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true
    }
  }
  return false
}

function checkStat (stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false
  }
  return checkPathExt(path, options)
}

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), path, options)
}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(4)

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), options)
}

function checkStat (stat, options) {
  return stat.isFile() && checkMode(stat, options)
}

function checkMode (stat, options) {
  var mod = stat.mode
  var uid = stat.uid
  var gid = stat.gid

  var myUid = options.uid !== undefined ?
    options.uid : process.getuid && process.getuid()
  var myGid = options.gid !== undefined ?
    options.gid : process.getgid && process.getgid()

  var u = parseInt('100', 8)
  var g = parseInt('010', 8)
  var o = parseInt('001', 8)
  var ug = u | g

  var ret = (mod & o) ||
    (mod & g) && gid === myGid ||
    (mod & u) && uid === myUid ||
    (mod & ug) && myUid === 0

  return ret
}


/***/ })
/******/ ])));